compilationUnit
    : declarations*
    ;

declarations
    : includeDeclaration
    | classDeclaration
    | methodImplementation
    ;

//
// includeDeclaration
//
includeDeclaration
    : 'include' STRING 
    ;

//
// classDeclaration
//
classDeclaration
    : scopeSpecifier ? classSignature? 'class' IDENTIFIER (classInheritDeclaration)?(abstractClassImplementDeclaration)? classBlock
    ;
    
classSignature
    : 'final'
    | 'abstract'
    ;

classInheritDeclaration
    : 'extend' IDENTIFIER (',' IDENTIFIER)*
    ;
    
abstractClassImplementDeclaration
    : 'implements' IDENTIFIER (',' IDENTIFIER)*
    ;

classBlock
    : '{' (scopeSpecifier? classMember)* '}'
    ;

classMember
    : storageSpecifier? constSpecifier? typeSpecifier IDENTIFIER (methodDeclSelector | varDeclSelector)  
    ;

methodDeclSelector
    : formalParameterList ';' 
    ;
varDeclSelector
    : ('=' expression)? ';' 
    ;

varDeclaration
    : StorageSpecifier? constSpecifier? typeSpecifier IDENTIFIER ( '=' expression)? ';' 
    ; 

scopeSpecifier
    : 'public' | 'private'
    ;

typeSpecifier 
    : basicType
    | IDENTIFIER // custome type, such as struct, class
    | setType
    | mapType
    ;
    
basicType
    : 'bool'
    | 'string'
    | 'int'
    | 'float'
    | 'id'
    | 'void' 
    ;

iterableType
    : 'bool'
    | 'string'
    | 'int'
    | 'float'
    | 'id'
    | IDENTIFIER
    ;
mapType
    : 'map' '<'iterableType, iterableType '>' 
    ;
setType
    : 'set' '<'iterableType '>'
    ;
    
//
// varDeclaration
//

storageSpecifier
    : 'static'
    ;
constSpecifier
    : 'const'
    ;

//
// methodDeclaration
//

methodDeclaration
    : storageSpecifier? constSpecifier? typeSpecifier IDENTIFIER formalParameterList ';'
    ;
methodImplementation
    : storageSpecifier? constSpecifier? typeSpecifier IDENTIFIER '::' IDENTIFIER formalParameterList methodBlock
    ;

formalParameterList
    : '('')'
    | '(' normalFormalParameters (',' defaultFormalParameters)? ')'
    ;

normalFormalParameters
    : normalFormalParameter (',' normalFormalParameter)*
    ;
normalFormalParameter
    : constSpecifier? typeSpecifier IDENTIFIER 
    ;

defaultFormalParameters
    : defaultFormalParameter (',' defaultFormalParameter)*
    ;

defaultFormalParameter
    : normalFormalParameter ('=' expression)?
    ;


methodBlock
    : '{' statement* '}'
    ;

//
// statements
//
statements
    : statement*
    ;

statement
    : blockStatement
    | varDeclStatement
    | ifStatement
    | forStatement
    | foreachStatement
    | doStatement
    | whileStatement
    | returnStatement
    | tryStatement
    | throwStatement
    | breakStatement
    | continueStatement
    | assertStatement
    | newStatement
    | expressionStatement
 //   | methodCallStatement
    ;

// blockStatement
blockStatement
    : '{' statement* '}'
    ;

// varDeclStatement
varDeclStatement
    : StorageSpecifier? constSpecifier? typeSpecifier IDENTIFIER ( '=' expression)? ';' 
    ;

// ifStatement
ifStatement
    : 'if' '(' comparisonExpr ')' (blockStatement |statement) ('else' (blockStatement |statement))?
    ;

// forStatement
forStatement
    : 'for' '('expression? ';' comparisonExpr? ';' expressionList? ')' (blockStatement | statement)
    ;

// foreachStatement    
foreachStatement
    : 'foreach' '(' foreachVarItem (',' foreachVarItem)? 'in' foreachSetObject ')' (blockStatement | statement)
    ;

// foreachVarItem
foreachVarItem
     : typeSpecifier IDENTIFIER
     ;
// foreachSetObject
foreachSetObject
    : IDENTIFIER
    | mapLiteral
    | setLiteral
    ;

// whileStatement
whileStatement
    : 'while' '(' comparisonExpr ')' (blockStatement|statement)
    ;

// doStatement
doStatement
    : 'do' (blockStatement|statement) 'while' '(' comparisonExpr ')'
    ;

// switchStatement
switchStatement
    : 'switch' '(' expression ')' '{' switchCase*defaultCase? '}'
    ;

switchCase
    : ('case' expression ':')+ statement
    ;

defaultCase
    : 'default' ':' statement
    ;

// returnStatement
returnStatement
    : 'return' expression? ';'
    ;

// breakStatement
breakStatement
    : 'break' ';'
    ;

// continueStatement
continueStatement
    : 'continue' ';'
    ;

// assertStatement
assertStatement
    : 'assert' '(' expression ')' ';'
    ;

// throwStatement
throwStatement
    : 'throw' expression? ';'
    ;


// tryStatement
tryStatement
    : 'try' blockStatement catchParts? finallyPart?
    ;

catchParts
    : catchPart*
    ;
catchPart
    : 'catch' '('typeSpecifier IDENTIFIER ')'  blockStatement
    ;

finallyPart
    : 'finally' blockStatement
    ;


// expressionStatement
expressionStatement
    : expression ( assignmentOperator expression)?';'
    ;
//
// expr
//
expressionList
    : expression (',' expression)*
    ;

newExpr
    : 'new' typeSpecifier arguments 
    ;

// assignmentOperator
assignmentOperator
    : '='
    | '+='
    | '-='
    | '*='
    | '/='
    | '<<='
    | '>>='
    | '&='
    | '|='
    | '^='
    | '~='
    ;

comparisonOperator
    : '<'
    | '>'
    | '=='
    | '>='
    | '<='
    | '!='
    | 'not'
    | 'is'
    | 'is' 'not'
    | 'not' 'in'
    | 'in'
    ;

comparisonExpr
    : expression (comparisonOperator expression)*
    ;

expression
    : logicalOrExpr 
    | newExpr 
    ;

logicalOrExpr
    : logicalAndExpr ('||' logicalAndExpr)*
    ;

logicalAndExpr
    : bitwiseOrExpr ('&&' bitwiseOrExpr)*
    ;

bitwiseOrExpr
    : bitwiseXorExpr ('|' bitwiseXorExpr)*
    ;

bitwiseXorExpr
    : bitwiseAndExpr ('^' bitwiseAndExpr)*
    ;

bitwiseAndExpr
    : equalityExpr ('&' equalityExpr)*
    ;

equalityOperator
    : '=='
    | '!='
    ;

equalityExpr
    : relationalExpr (equalityOperator relationalExpr)*
    ;
relationalOperator
    : '>='
    | '<='
    | '>'
    | '<'
    ;

relationalExpr
    : shiftExpr (relationalOperator shiftExpr)*
    ;

shiftExpr
    : additiveExpr (shiftOperator additiveExpr)*
    ;

shiftOperator
    : '<<'
    | '>>'
    ;

additiveExpr
    : multiplicativeExpr (additiveOperator multiplicativeExpr)*
    ;

additiveOperator
    : '+'
    | '-'
    ;

multiplicativeExpr
    : unaryExpr (multiplicativeOperator unaryExpr)*
    ;

multiplicativeOperator
    : '*'
    | '/'
    | '%'
    ;

unaryExpr
    : primary selector*
    ;

selector
    : assignableSelector
    | arguments
    ;


newStatement
    : 'new' IDENTIFIER FormalParameterList 
    ;
// primary
primary
    : 'self'
    | 'super'
    | 'null'
    | 'true'
    | 'false'
    | NUMBER
    | HEXNUMBER
    | FLOATNUMBER 
    | STRING
    | mapLiteral
    | setLiteral
    | IDENTIFIER
    | '(' expression ')'
    ;

arguments
    : '(' argumentList? ')'
    ;

argumentList
    : expression (',' expression)*
    ;
assignableSelector
    : '.'IDENTIFIER
    | '[' expression ']'
    ;

setLiteral
    :'[' expressionList? ']'
    ;

mapLiteral
    : '{' mapLiteralItems? '}'
    ;

mapLiteralItems
    : mapLiteralItem (',' mapLiteralItem)*
    ;

mapLiteralItem
    : IDENTIFIER':' expression
    | STRING ':' expression
    | NUMBER ':' expression
    | HEXNUMBER ':' expression
    ;

